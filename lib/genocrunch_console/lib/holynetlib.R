#holynetlib.R

#################################################  
# Create Similarity Matrix
# Args:
# (1) table             (data.frame) 
# (2) dist_metric       (character) Possible options are "bray", "jaccard", "canberra", "manhattan", "gower"
# Returns: A similarity matrix of nxn dimension (n = number of samples) according to a distance metric defined by the user
################################################# 
CreateSimilarityMatrix <- function(table, dist_metric) {
  suppressMessages(library(vegan))
  sim_table <- as.matrix(1-vegdist(t(table), method = dist_metric, binary = FALSE, diag = TRUE, upper = TRUE))
  diag(sim_table) <- NA
  return(sim_table)
}

#################################################  
# Create Adjacency Matrix
# Args:
# (1) sim_matrix        (matrix)
# Returns: An adjacency matrix calculated by using linear transformation of the similarity matrix
#################################################
CreateAdjacencyMatrix <- function(sim_matrix) {
  adj_matrix <- (sim_matrix-min(sim_matrix, na.rm = TRUE))/(max(sim_matrix, na.rm = TRUE)-min(sim_matrix, na.rm = TRUE))
  diag(adj_matrix) <- 1 # Diagonal is required 
  return(adj_matrix)
}

#################################################  
# Test for identical row-names in multiple data-frames
# Args:
# (1) mat  (list of data-frames)
# Returns: A logical value TRUE if the headers and dimensions match, FALSE otherwise
################################################# 
HasIdenticalRowNames <- function(mat) {
  for (i in 2:length(mat)) {
    if (identical(rownames(mat[[i]]), rownames(mat[[1]])) == FALSE) {
      return(FALSE)
    }
  }
  return(TRUE)
}

#################################################  
# Fuse Matrices
# Args:
# (1) mat  (list of numeric matrices) Adjacency matrices
# (2) k    (numeric) (OPTIONAL) Number of neighbors in K-nearest neighbors part of the algorithm
# (3) t    (numeric) Number of iterations for the diffusion process
# Returns: A fusion matrix
################################################# 
FuseMatrices <- function(mat, k = ncol(mat[[1]])^(1/2), t = 100) {
  if (HasIdenticalRowNames(mat) == TRUE) {
    suppressMessages(library(SNFtool))
    fusion.matrix <- SNF(mat, k, t)
    rownames(fusion.matrix) <- rownames(mat[[1]])
    colnames(fusion.matrix) <- colnames(mat[[1]])
    fusion.matrix <- CreateAdjacencyMatrix(fusion.matrix)
    diag(fusion.matrix) <- NA
    return(fusion.matrix)
  }
  return(NULL)
}

#################################################  
# Create network from adjacency matrix
# Args:
# (1) mat  (matrix)  matrix generated by the CreateAdjacencyMatrix function
# Returns: A graph object-type (igraph)
################################################# 
CreateNetwork <- function(mat) {
  suppressMessages(library(igraph))
  network <- graph_from_adjacency_matrix(mat, mode = c("undirected"), weighted = TRUE, diag = FALSE,
                                         add.colnames = FALSE, add.rownames = FALSE)
  V(network)$name <- paste(rownames(mat))
  return(network)
}

#################################################  
# Apply network-based clustering
# Args:
# (1) network    (igraph)    Network object generated by the CreateNetwork function
# (2) clust_method      (character) Possible options are: "fastgreedy","louvain","walktrap","labelpropagation" of the igraph package
# Returns: A numeric vector with cluster number for each sample
################################################# 
ApplyNetworkClustering <- function(network, clust_method) {
  suppressMessages(library(igraph))
  if (clust_method == "fastgreedy") {
    network_cluster <- cluster_fast_greedy(network, merges = TRUE, modularity = TRUE, membership = TRUE,
                                           weights = E(network)$weight)}
  
  if (clust_method == "louvain") {
    network_cluster <- cluster_louvain(network, weights = E(network)$weight)}
  
  if (clust_method == "walktrap") {
    network_cluster <- cluster_walktrap(network, weights = E(network)$weight, steps = 4, merges = TRUE, modularity = TRUE, 
                                        membership = TRUE)}
  
  if (clust_method == "labelpropagation") {
    network_cluster <- label.propagation.community(network, weights = E(network)$weight, initial = NULL, fixed = NULL)}
  return(network_cluster$membership)
}





